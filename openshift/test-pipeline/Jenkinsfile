#!groovy

def s2iWebhook = registerWebhook()
def build = ""
def latestTag = "${RELEASE_VERSION}.latest"
def appReleaseName = "${APP_NAME}-${RELEASE_VERSION}"
def dbName = "${appReleaseName}-${new Random().nextInt() % 1000}".replace('-', '')
def tmpDir = "${appReleaseName}-tmp"

// Parameters for backing service. Scope global so we can clean up
def intygstjanstBackingService = ""
def intygstjanstBackingServiceName = ""
def intygstjanstBackingServiceAppName = ""
def intygstjanstBackingServiceAppVersion = ""
def intygstjanstBackingServiceDbName = ""

def webcertBackingService = ""
def webcertBackingServiceName = ""
def webcertBackingServiceAppName = ""
def webcertBackingServiceAppVersion = ""
def webcertBackingServiceDbName = ""

def webcertFrontendBackingService = ""
def webcertFrontendBackingServiceName = ""
def webcertFrontendBackingServiceAppName = ""
def webcertFrontendBackingServiceAppVersion = ""
def webcertFrontendBackingServiceDbName = ""

// function to run database commands
def dbScript(cmd) {
  sh(
          script: "oc rsh \$(oc get pods | grep mysql- | grep Running | awk \'{ print \$1 }\')  bash -c \"mysql -u root -e \'${cmd}\'\"",
          returnStatus: true
  )
}

// run shell command, return status code
def shell(cmd) {
    sh(
            script: cmd,
            returnStatus: true
    )
}

// run shell command and signal an error on failure
def eshell(cmd) {
    def rc = shell(cmd)
    if (rc != 0) {
        error("Error: shell command exited with error code ${rc}")
    }
}

def log(msg) {
    echo "${new Date().format('yyyy-MM-dd HH:mm:ss.SSS')} : ${msg}"
}

// function to extract openshift stage configuration only from repo. dir must not exist
// returns build version. This is only used for Intygstjänst as a backing service
def extractConfig(dir, url, ref, stage, latestTag) {
  eshell("rm -rf ${dir}")
  eshell("mkdir ${dir}")
  def wd = "cd ${dir}; "
  eshell(wd + "git init")
  eshell(wd + "git remote add origin -f ${url} 2> /dev/null")
  eshell(wd + "git config core.sparsecheckout true")
  eshell(wd + "echo 'devops/openshift/${stage}/*' >> .git/info/sparse-checkout")
  if (ref.startsWith("v")) {
    log "Extract config - Get tag for ${ref}"
    if (ref.endsWith('.+')) {
      ref = ref.replace('+', '')
    }
    def tag = sh(
            script: wd + "git tag -l | grep ${ref} | sort -V | tail -1",
            returnStdout: true
    ).trim()
    log "Extract config - Start checkout for ${ref}"
    eshell(wd + "git checkout tags/${tag}")
    log "Extract config - Finish checkout for ${ref}"
    return tag.substring(1)
  } else {
    log "Extract config - Start checkout for ${ref}"
    eshell(wd + "git checkout ${ref}")
    log "Extract config - Finish checkout for ${ref}"
    return "${latestTag}"
  }
}

pipeline {
    agent any

    stages {

//         stage('Checkout Source') {
//             steps {
//                 script {
//                     git url: "https://github.com/sklintyg/frontend.git", branch: GIT_BRANCH
//                 }
//             }
//         }

        stage('Deploy Intygstjänst') {
            steps {
                script {
                    openshift.withCluster() {
                        openshift.withProject() {
                          // [ name, tag ] default version is "${RELEASE_VERSION}.latest"
                          // def svc = (backingService.contains(":") ? backingService : backingService + ":${latestTag}").split(":")
                          intygstjanstBackingServiceName = "intygstjanst"
                          def intygstjanstBackingServiceVersion = "3.15.0.+"
                          def healthUri = "inera-certificate"

                          log "Create database"
                          intygstjanstBackingServiceDbName = "${intygstjanstBackingServiceName.replace('-', '')}${dbName}"
                          def status = dbScript("create database ${intygstjanstBackingServiceDbName} character set utf8mb4;")
                          if (status != 0) {
                            error("Unable to create database ${intygstjanstBackingServiceDbName}")
                          }

                          // checkout actual configuration for the base service version, then copy to the actual backing service name.
                          // Note: not multi-thread safe, implies one build at a time
                          intygstjanstBackingServiceAppName = "${intygstjanstBackingServiceName}-${appReleaseName}"
                          def svcGitRef = intygstjanstBackingServiceVersion.equals("${latestTag}") ? "${GIT_BRANCH}" : "v${intygstjanstBackingServiceVersion}"

                          // Replace configured intygstjanstBackingServiceVersion with the version extracted from git tag
                          log "Extract config for intygstjanst ${svcGitRef}"
                          intygstjanstBackingServiceAppVersion = extractConfig(tmpDir, "https://github.com/sklintyg/intygstjanst.git", svcGitRef, "${STAGE}", latestTag)

                          // Delete any old resources
                          log "Delete old resources"
                          shell("oc delete configmap ${intygstjanstBackingServiceAppName}-config")
                          shell("oc delete configmap ${intygstjanstBackingServiceAppName}-configmap-envvar")
                          shell("oc delete secret ${intygstjanstBackingServiceAppName}-env")
                          shell("oc delete secret ${intygstjanstBackingServiceAppName}-certifikat")
                          shell("oc delete secret ${intygstjanstBackingServiceAppName}-secret-envvar")

                          // Create new resources
                          log "Create new resources"
                          def wd = "cd ${tmpDir}/devops/openshift; "
                          eshell(wd + "oc create configmap ${intygstjanstBackingServiceAppName}-configmap-envvar --from-env-file=${STAGE}/configmap-envvar.properties")
                          eshell(wd + "oc create configmap ${intygstjanstBackingServiceAppName}-config --from-file=${STAGE}/config/")
                          eshell(wd + "oc create secret generic ${intygstjanstBackingServiceAppName}-secret-envvar --from-env-file=${STAGE}/secret-envvar.properties --type=Opaque")
                          eshell(wd + "oc create secret generic ${intygstjanstBackingServiceAppName}-env --from-file=${STAGE}/env/ --type=Opaque")
                          eshell(wd + "oc create secret generic ${intygstjanstBackingServiceAppName}-certifikat --from-file=${STAGE}/certifikat/ --type=Opaque")

                          def imageStream = openshift.selector("is", "${intygstjanstBackingServiceName}-verified").object().status.dockerImageRepository
                          log "Use ImageStream ${imageStream}:${intygstjanstBackingServiceAppVersion}"

                          def deployModel = openshift.process("-f", "${env.WORKSPACE}/openshift/test-pipeline/deploytemplate-webapp.yaml",
                                  "-p", "APP_NAME=${intygstjanstBackingServiceAppName}",
                                  "-p", "IMAGE='${imageStream}:${intygstjanstBackingServiceAppVersion}'",
                                  "-p", "DATABASE_NAME=${intygstjanstBackingServiceDbName}",
                                  "-p", "HEALTH_URI=${healthUri}",
                                  "-p", "STAGE=test")
                          log "Wait for rollout (limited to 5 minutes)"
                          timeout(5) {
                            def rm = openshift.apply(deployModel).narrow("dc").rollout()
                            log "Waiting for deployment to complete"
                            rm.status()
                            log "Deployment done."
                          }
                        }
                    }
                }
            }
        }

        stage('Deploy Webcert') {
            steps {
                script {
                    openshift.withCluster() {
                        openshift.withProject() {
                          // [ name, tag ] default version is "${RELEASE_VERSION}.latest"
                          // def svc = (backingService.contains(":") ? backingService : backingService + ":${latestTag}").split(":")
                          webcertBackingServiceName = "webcert"
                          def webcertBackingServiceVersion = "6.10.0.+"
                          def healthUri = "/"

                          log "Create database"
                          webcertBackingServiceDbName = "${webcertBackingServiceName.replace('-', '')}${dbName}"
                          def status = dbScript("create database ${webcertBackingServiceDbName} character set utf8mb4;")
                          if (status != 0) {
                            error("Unable to create database ${webcertBackingServiceDbName}")
                          }

                          // checkout actual configuration for the base service version, then copy to the actual backing service name.
                          // Note: not multi-thread safe, implies one build at a time
                          webcertBackingServiceAppName = "${webcertBackingServiceName}-${appReleaseName}"
                          def svcGitRef = webcertBackingServiceVersion.equals("${latestTag}") ? "${GIT_BRANCH}" : "v${webcertBackingServiceVersion}"

                          // Replace configured webcertBackingServiceVersion with the version extracted from git tag
                          log "Extract config for webcert ${svcGitRef}"
                          webcertBackingServiceAppVersion = extractConfig(tmpDir, "https://github.com/sklintyg/webcert.git", svcGitRef, "${STAGE}", latestTag)

                          // Delete any old resources
                          log "Delete old resources"
                          shell("oc delete configmap ${webcertBackingServiceAppName}-config")
                          shell("oc delete configmap ${webcertBackingServiceAppName}-configmap-envvar")
                          shell("oc delete secret ${webcertBackingServiceAppName}-env")
                          shell("oc delete secret ${webcertBackingServiceAppName}-certifikat")
                          shell("oc delete secret ${webcertBackingServiceAppName}-secret-envvar")

                          // Create new resources
                          log "Create new resources"
                          def wd = "cd ${tmpDir}/devops/openshift; "
                          eshell(wd + "oc create configmap ${webcertBackingServiceAppName}-configmap-envvar --from-env-file=${STAGE}/configmap-envvar.properties")
                          eshell(wd + "oc create configmap ${webcertBackingServiceAppName}-config --from-file=${STAGE}/config/")
                          eshell(wd + "oc create secret generic ${webcertBackingServiceAppName}-secret-envvar --from-env-file=${STAGE}/secret-envvar.properties --type=Opaque")
                          eshell(wd + "oc create secret generic ${webcertBackingServiceAppName}-env --from-file=${STAGE}/env/ --type=Opaque")
                          eshell(wd + "oc create secret generic ${webcertBackingServiceAppName}-certifikat --from-file=${STAGE}/certifikat/ --type=Opaque")

                          def imageStream = openshift.selector("is", "${webcertBackingServiceName}-verified").object().status.dockerImageRepository
                          log "Use ImageStream ${imageStream}:${webcertBackingServiceAppVersion}"

                          def deployModel = openshift.process("-f", "${env.WORKSPACE}/openshift/test-pipeline/deploytemplate-webapp.yaml",
                                  "-p", "APP_NAME=${webcertBackingServiceAppName}",
                                  "-p", "IMAGE='${imageStream}:${webcertBackingServiceAppVersion}'",
                                  "-p", "DATABASE_NAME=${webcertBackingServiceDbName}",
                                  "-p", "HEALTH_URI=${healthUri}",
                                  "-p", "STAGE=test")
                          log "Wait for rollout (limited to 5 minutes)"
                          timeout(5) {
                            def rm = openshift.apply(deployModel).narrow("dc").rollout()
                            log "Waiting for deployment to complete"
                            rm.status()
                            log "Deployment done."
                          }
                        }
                    }
                }
            }
        }

        stage('Deploy Webcert-frontend') {
            steps {
                script {
                    openshift.withCluster() {
                        openshift.withProject() {
                          webcertFrontendBackingServiceName = "webcert-frontend"
                          def webcertFrontendBackingServiceVersion = "6.10.0.+"
                          def healthUri = "/"

                          // checkout actual configuration for the base service version, then copy to the actual backing service name.
                          // Note: not multi-thread safe, implies one build at a time
                          webcertFrontendBackingServiceAppName = "${webcertFrontendBackingServiceName}-${appReleaseName}"
                          webcertFrontendBackingServiceAppVersion = "latest"

                          // Delete any old resources
                          log "Delete old resources"
                          shell("oc delete configmap ${webcertFrontendBackingServiceAppName}-configmap-envvar")
                          shell("oc delete secret ${webcertFrontendBackingServiceAppName}-secret-envvar")

                          // Create new resources
                          log "Create new resources"
                          eshell("oc create configmap ${webcertFrontendBackingServiceAppName}-configmap-envvar --from-env-file=${env.WORKSPACE}/openshift/test-pipeline/configmap-envvar.properties")
                          eshell("oc create secret generic ${webcertFrontendBackingServiceAppName}-secret-envvar --from-env-file=${env.WORKSPACE}/openshift/test-pipeline/secret-envvar.properties --type=Opaque")

                          def imageStream = openshift.selector("is", "${webcertFrontendBackingServiceName}").object().status.dockerImageRepository
                          log "Use ImageStream ${imageStream}:${webcertFrontendBackingServiceAppVersion}"

                          def deployModel = openshift.process("-f", "${env.WORKSPACE}/openshift/test-pipeline/deploytemplate-frontend.yaml",
                                  "-p", "APP_NAME=${webcertFrontendBackingServiceAppName}",
                                  "-p", "IMAGE='${imageStream}:${webcertFrontendBackingServiceAppVersion}'",
                                  "-p", "WEBCERT_API=${webcertBackingServiceAppName}",
                                  "-p", "HEALTH_URI=${healthUri}",
                                  "-p", "STAGE=test")
                          log "Wait for rollout (limited to 5 minutes)"
                          timeout(5) {
                            def rm = openshift.apply(deployModel).narrow("dc").rollout()
                            log "Waiting for deployment to complete"
                            rm.status()
                            log "Deployment done."
                          }
                        }
                    }
                }
            }
        }

        stage('Execute e2e-tests') {
            steps {
                script {
                    yarn command: 'init -y'
                    yarn command: 'workspace @frontend/webcert-e2e cy:run'
                }
            }
        }
    }

    post {
        success {
            script {
                log "Pipeline success :)"
                util.notifySuccess()
            }
        }

        failure {
            script {
                log "Pipeline Failed :("
                util.notifyFailed()
            }
        }

        always {
          script {
            echo "cleanup"
            openshift.withCluster() {
              openshift.withProject() {
                // Clean up after Intygstjanst

                echo "Logs for ${intygstjanstBackingServiceAppName}"
                openshift.selector("dc", "${intygstjanstBackingServiceAppName}").logs()

                imageStream = openshift.selector("is", "${intygstjanstBackingServiceName}-verified").object().status.dockerImageRepository

                shell("oc process -f ${env.WORKSPACE}/openshift/test-pipeline/deploytemplate-webapp.yaml -p APP_NAME=\"${intygstjanstBackingServiceAppName}\" -p IMAGE=\"${imageStream}:${intygstjanstBackingServiceAppVersion}\" -p STAGE=${STAGE} -p DATABASE_NAME=${intygstjanstBackingServiceDbName} | oc delete -f -")
                dbScript("drop database ${intygstjanstBackingServiceDbName};")

                shell("oc delete configmap ${intygstjanstBackingServiceAppName}-config")
                shell("oc delete secret ${intygstjanstBackingServiceAppName}-env")
                shell("oc delete secret ${intygstjanstBackingServiceAppName}-certifikat")
                shell("oc delete configmap ${intygstjanstBackingServiceAppName}-configmap-envvar")
                shell("oc delete secret ${intygstjanstBackingServiceAppName}-secret-envvar")

                // Clean up after Webcert

                echo "Logs for ${webcertBackingServiceAppName}"
                openshift.selector("dc", "${webcertBackingServiceAppName}").logs()

                imageStream = openshift.selector("is", "${webcertBackingServiceName}-verified").object().status.dockerImageRepository

                shell("oc process -f ${env.WORKSPACE}/openshift/test-pipeline/deploytemplate-webapp.yaml -p APP_NAME=\"${webcertBackingServiceAppName}\" -p IMAGE=\"${imageStream}:${webcertBackingServiceAppVersion}\" -p STAGE=${STAGE} -p DATABASE_NAME=${webcertBackingServiceDbName} | oc delete -f -")
                dbScript("drop database ${webcertBackingServiceDbName};")

                shell("oc delete configmap ${webcertBackingServiceAppName}-config")
                shell("oc delete secret ${webcertBackingServiceAppName}-env")
                shell("oc delete secret ${webcertBackingServiceAppName}-certifikat")
                shell("oc delete configmap ${webcertBackingServiceAppName}-configmap-envvar")
                shell("oc delete secret ${webcertBackingServiceAppName}-secret-envvar")

                // Clean up after Webcert-frontend

                echo "Logs for ${webcertFrontendBackingServiceAppName}"
                openshift.selector("dc", "${webcertFrontendBackingServiceAppName}").logs()

                imageStream = openshift.selector("is", "${webcertFrontendBackingServiceName}").object().status.dockerImageRepository

                shell("oc process -f ${env.WORKSPACE}/openshift/test-pipeline/deploytemplate-frontend.yaml -p APP_NAME=\"${webcertFrontendBackingServiceAppName}\" -p IMAGE=\"${imageStream}:${webcertFrontendBackingServiceAppVersion}\" -p STAGE=${STAGE} -p WEBCERT_API=${webcertBackingServiceAppName} | oc delete -f -")

                shell("oc delete configmap ${webcertFrontendBackingServiceAppName}-configmap-envvar")
                shell("oc delete secret ${webcertFrontendBackingServiceAppName}-secret-envvar")
              }
            }
          }
        }

        cleanup {
            log "Clean up in post work space"
            cleanWs()
        }
    }
}
