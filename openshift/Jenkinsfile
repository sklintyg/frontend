#!groovy

def artifactFolder = "target"
def applicationZip = "${artifactFolder}/webcert-frontend-latest.tar.gz"

// run shell command, return status code
def shell(cmd) {
    sh(
            script: cmd,
            returnStatus: true
    )
}

// run shell command and signal an error on failure
def eshell(cmd) {
    def rc = shell(cmd)
    if (rc != 0) {
        error("Error: shell command exited with error code ${rc}")
    }
}

def log(msg) {
    echo "${new Date().format('yyyy-MM-dd HH:mm:ss.SSS')} : ${msg}"
}

pipeline {
    agent any

    stages {

        stage('Checkout Source') {
            steps {
                script {
                    git url: "https://github.com/sklintyg/frontend.git", branch: "feature/INTYGFV-13885"
                }
            }
        }

        stage('Prepare source') {
            steps {
                script {
                    def applicationDir = "."
                    if (!fileExists("${artifactFolder}")) {
                        eshell("mkdir -p ${artifactFolder}")
                    }
                    eshell("tar --exclude ${artifactFolder} --exclude .git -chzf ${applicationZip} ${applicationDir}")
                    archiveArtifacts artifacts: "${applicationZip}", excludes: null, onlyIfSuccessful: true
                }
            }
        }

//        stage('Setup Image Builds') {
//            steps {
//                script {
//                    openshift.withCluster() {
//                        openshift.withProject() {
//                            def models = openshift.process("-f", "openshift/buildtemplate-frontend.yaml",
//                                    "-p", "IS_APP_NAME=webcert-frontend",
//                                    "-p", "APP_NAME=webcert-frontend",
//                                    "-p", "STAGE=test",
//                                    "-p", "BUILD_VERSION=latest",
//                                    "-p", "ARTIFACT_IMAGE_SUFFIX=artifact")
//                            openshift.apply(models)
//                        }
//                    }
//                }
//            }
//        }

        stage('Create Artifact Image') {
            steps {
                script {
                    openshift.withCluster() {
                        openshift.withProject() {
                            // Setup callback webhook
                            def testReportHook = registerWebhook()
                            def lintReportHook = registerWebhook()

                            openshift.withProject() {
                                def models = openshift.process("-f", "openshift/buildtemplate-frontend.yaml",
                                        "-p", "IS_APP_NAME=webcert-frontend",
                                        "-p", "APP_NAME=webcert-frontend",
                                        "-p", "STAGE=test",
                                        "-p", "BUILD_VERSION=latest",
                                        "-p", "ARTIFACT_IMAGE_SUFFIX=artifact",
                                        "-p", "LINT_REPORT_CALLBACK_URL='${lintReportHook.getURL()}'",
                                        "-p", "TEST_REPORT_CALLBACK_URL='${testReportHook.getURL()}'")
                                openshift.apply(models)
                            }

                            log "Build artifact image webcert-frontend-artifact"
                            def build = openshift.selector("bc", "webcert-frontend-artifact").startBuild("--from-archive=${applicationZip}")
                            sleep(time: 1, unit: 'SECONDS')
                            log "${build.name()} started"

                            timeout(10) {
                                log "Waiting (max 10 min) for POST of lint-report to ${lintReportHook.getURL()}"
                                def lintReport = waitForWebhook(lintReportHook)

                                def lintReportPath = 'lint-result.xml'
                                writeFile file: lintReportPath, text: lintReport.replaceAll("/tmp/src", ".")

                                recordIssues enabledForFailure: true, aggregatingResults: true, tool: checkStyle(pattern: 'lint-result.xml')
                            }

                            timeout(10) {
                                log "Waiting (max 10 min) for POST of test-report to ${lintReportHook.getURL()}"
                                def testReport = waitForWebhook(lintReportHook)

                                def testReportPath = 'junit.xml'
                                writeFile file: testReportPath, text: testReport

                                junit checksName: 'Unit tests', testResults: testReportPath
                            }

                            timeout(10) {
                                log "Waiting (max 10 min) for POST of coverage-report to ${lintReportHook.getURL()}"
                                def coverageReport = waitForWebhook(lintReportHook)

                                def coverageReportPath = 'cobertura-coverage.xml'
                                writeFile file: coverageReportPath, text: coverageReport

                                cobertura coberturaReportFile: coverageReportPath
                            }

                            timeout(30) {
                                def status = ""
                                build.untilEach(1) {
                                    status = it.object().status.phase
                                    log "Build status: ${status}"
                                    return !["Running", "Pending", "New"].contains(status)
                                }

                                log "Logs for artifact build"
                                build.logs()
                                if (status != "Complete") {
                                    error("Build terminated with status: ${status}")
                                }
                                log "Build Completed"
                            }
                        }
                    }
                }
            }
        }

        stage('Create Runtime Image') {
            steps {
                script {
                    openshift.withCluster() {
                        openshift.withProject() {
                            log "Build runtime image webcert-frontend"
                            def build = openshift.selector("bc", "webcert-frontend").startBuild()
                            sleep(time: 1, unit: 'SECONDS')
                            log "${build.name()} started"
                            timeout(45) {
                                def status = ""
                                build.untilEach(1) {
                                    status = it.object().status.phase
                                    log "Build status: ${status}"
                                    return !["Running", "Pending", "New"].contains(status)
                                }
                                log "Logs for docker runtime build"
                                build.logs()
                                if (status != "Complete") {
                                    error("Build terminated with status: ${status}")
                                }
                                log "Build Completed"
                            }
                        }
                    }
                }
            }
        }
    }

    post {
        success {
            script {
                log "Pipeline success :)"
                util.notifySuccess()
            }
        }

        failure {
            script {
                log "Pipeline Failed :("
                util.notifyFailed()
            }
        }

        cleanup {
            log "Clean up in post work space"
            cleanWs()
        }
    }
}
